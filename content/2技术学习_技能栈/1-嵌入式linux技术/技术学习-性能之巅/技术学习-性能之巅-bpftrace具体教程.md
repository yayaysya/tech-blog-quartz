









---
# bpftrace的探针

定时器探针和定时采样探针是 BPF (Berkeley Packet Filter) 动态追踪工具中，用于**主动**获取系统状态的两种特殊机制。它们与我们之前讨论的那些基于特定事件（如函数调用、系统调用）的追踪方式是相辅相成的。

### 它们之间的关系

传统的 BPF 动态追踪，比如 `uprobe` (用户态探针) 或 `kprobe` (内核态探针)，是**事件驱动**的。这意味着你的脚本只会在某个特定的函数被调用时（比如 `pthread_mutex_lock`）才会被触发，从而获取数据。这非常适合用来追踪**特定事件的发生**和相关信息，比如锁的竞争、文件 I/O 的调用路径等。

然而，如果你的目标是分析**一段时间内的整体系统行为**，而不是某个具体事件，事件驱动的探针就不够了。例如，你想知道：

- 哪个函数在过去 30 秒内占用了最多的 CPU？
    
- 系统每隔 10 秒的平均负载是多少？
    

在这种情况下，你无法预知该追踪哪个“事件”。这时，定时器探针和定时采样探针就派上用场了。它们提供了**时间驱动**的追踪能力。

---

### 定时器探针 (interval)

- **工作方式**: 在一个预设的时间间隔后触发一次。例如，`interval:s:5` 表示每 5 秒触发一次。
    
- **主要用途**: 用于**周期性地执行任务**，例如：
    
    - **周期性报告**: 每隔一段时间打印一次统计结果。
        
    - **定时清理**: 定时清空 BPF 映射 (map) 中的数据，防止溢出。
        
- **与事件追踪的关系**: 它通常不用于数据收集本身，而是作为事件追踪的**辅助工具**，用于控制脚本的生命周期、打印结果或执行其他定期维护任务。
    

### 定时采样探针 (profile)

- **工作方式**: 以一个预设的固定频率触发。例如，`profile:hz:99` 表示每秒触发 99 次。
    
- **主要用途**: 用于**持续性地采样系统状态**，最常见的应用就是性能分析。
    
- **与事件追踪的关系**: 这是对事件追踪的有力补充。通过高频采样，你可以得到一个**概率性的“快照”**。比如，如果一个函数在 1000 次采样中被捕捉到 500 次，那么它很可能就是 CPU 消耗的瓶颈，即使你不知道它是被谁调用的。这种方法非常适合**生成火焰图**，因为火焰图就是基于大量的 CPU 采样数据构建的。
    

总而言之，如果你想知道**“何时”**和**“如何”**发生某个事件，使用事件驱动的探针；如果你想知道**“在一段时间内”**发生了什么，以及**“什么”**在消耗资源，使用定时器和定时采样探针。它们共同构成了 BPF 动态追踪的强大能力。